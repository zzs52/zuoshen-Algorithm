### 题目一
32位无符号整数的范围是0-2^32-1即0-4294967295，现在有一个正好包含40亿个无符号整数的文件，所以在整个范围中必然有没出现的数。可以使用最多1GB的内存。

#### 1.怎么知道所有没有出现过的数？

哈希表需要占用很多空间，可以使用bit map的方式来表示数出现的情况。具体地说，是申请一个长度为4294967295的bit类型的数组bitArr，bitArr上的每个位置只能表示0或1两个状态。

8个bit为1B，所以长度为为4294967195的bit类型的数组占用500MB空间。遍历这40亿个数，把遇到的数相应位置的值赋为1；遍历整个数组，值为0的下标即为没有出现过的数。

#### 2.内存限制为10MB，但是只要找到一个没出现过得数即可。

现在只有10MB的内存，但是也只要求找到其中一个没出现过的数即可。首先，0-2^32-1，这个范围是可以平均分成64个区间的，每个区间是67108864个数。如果统计落在每一个区间上的数有多少，肯定有至少一个区间上的计数少于67108864。具体过程为：

第一次遍历时，先申请长度为64的整形数组countArr[0..63]，countArr[i]用来统计区间i上的数有多少。遍历40亿个数时，如果当前数为3422552090,3422552090/67108864=51，所以第51区间上的技术增加countArr[51]++。遍历完40亿个数后，遍历countArr，必然会出现某一位置上的值小于67108864，表示该区间上至少有一个数没出现过。我们在该区间上继续寻找，此时使用的内存就是countArr的大小（64*4B），是非常小的。

假设找到第37区间上的计数小于67108864，以下为第二次遍历过程：

- 申请长度为67108864的bit map，这占用大约8MB的空间，记为bitArr[0..67108863];

- 再遍历一遍40亿个数，此时的遍历只关注落在第37区间上的数，记为num(num/67108864=37)，其他区间的数全部忽略；

- 如果步骤2上的num落在第37区间上，将bitArr[num-67108864*37]的值设置为1，也就是做映射；

- 遍历完40亿个数后，在bitArr上必然存在没被设置成1的位置，假设第i个位置上的值没设置成1，那么67108864*37+i，就是一个没出现过的数。

### 题目二
有一个包含100亿个URL的大文件，假设每个URL占用64B，找出其中所有重复的URL。

把大文件通过哈希函数分配到机器，或者通过哈希函数把大文件拆成小文件。一直进行这种划分，直到划分的结果满足资源限制的要求。

例如：将100亿个URL的大文件通过哈希函数分配到100台机器上，然后每一台机器分别统计分给自己的URL中是否含有重复的URL，同时哈希函数的性质决定了同一条URL不可能分配给不同的机器；或者单机上将单文件通过哈希函数拆成1000个小文件，对每一个小文件再利用哈希表遍历，找出重复的URL；或者在分给机器或拆成文件之后，进行排序，排序过后再看是否有重复的URL出现。

#### 进阶问题
某搜索公司一天的用户搜索词汇是海量的（百亿数据量），请设计一种求出每天最热top 100 词汇的可行办法。

（1）生成随机大数据，并且要求大数据存在交集数据，以此保证有热词存在。

（2）顺序读大文件，对于每一行，也就是每个词x，取hash(x)%n。
然后按照该值存到n个小文件中（即为1，2，3，4…..n），这样将MB级别，或者GB级别大文件分块成kb级别。
如果有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M；

（3）读入每一个小文件，利用hash_map统计每个文件中出现的词以及相应的频率，
创建动态数据结构node组，存储data（键值）和num（频率），利用最大堆排列，并取出出现频率最大的100个词，
这里注意不一定只有100词，需要统计100之后是否存在和100相同的值，并把100词和相应的频率以结构[key,num]存入文件中，这样又得到n个文件。

（4）把n个文件读入归并成1个文件all.txt，创建动态数据结构node组，存储data（键值）和num（频率），
利用最大堆排列，取出出现频率最大的100个词，思路到此。

### 题目三
32位无符号整数的范围是0-4294967295，现在有40亿个无符号整数，可以使用最多1GB的内存，找到所有出现了两次的数。

可以使用bit map的方式来表示数出现的情况。具体地说，是申请一个长度为4292967295*2的bit类型的数组bitArr，用2个位置表示一个数出现的词频，1B占用8个bit，所以长度为4294967295*2的bit类型的数组占用1GB空间。

开始遍历：

初次遇到：bitArr[num*2+1]=0;bitArr[num*2]=1;

第二次遇到：bitArr[num*2+1]=1;bitArr[num*2]=0;

第三次遇到：bitArr[num*2+1]=1;bitArr[num*2]=1;

以后再遇到：不作处理。

再次遍历bitArr，如果发现bitArr[i*2+1]=1;bitArr[i*2]=0;那么i就是出现了两次的数。

### 题目四
32位无符号整数的范围是0-4294967295，现在有40亿个无符号整数，可以使用最多10MB的内存，找到中位数。

用分区间的方式处理，将区间的数量定为10MB/4的最大2的幂次方，为2048。

申请一个长度为2048的无符号整型数组arr[0..2047]，arr[i]表示区间i有多少个数。然后遍历到当前数为num，先看num落在哪个区间上【num/2048】，然后执行arr[num/2048]++操作。这样遍历下来，就得到了每一个区间的数的出现状况，通过累加每个区间的出现次数，就可以找到40亿个数的中位数落在哪个区间(假设为第k区间)上。

接下来再申请一个长度为2048的无符号整形数组countArr[0..2047]，然后再遍历40亿个数，此时只关心处在第k区间的数，记为numi，其他的数省略，然后将countArr[numi/2048]++，也就是对处在第k区间的数做频率统计，重复这个过程，最终就可以找到。

### 腾讯面试题
在一个文件中有10G个整数，乱序排列，要求找出中位数。内存限制为2G。只写出思路即可。

#### 解法1
准备一个小根堆，小根堆里的一条记录由一个数和这个数出现的次数组成，按这个数的大小进行排列。

因为一个数占4B，次数占4B，再考虑堆的索引大小，所以一条记录我们算它占16B，所以这个堆里面能存放2G/16条记录，为2^27

对这10G个整数进行分组，第一组为-2^32 ~ -2^32 + 2^27 - 1，遍历整个10G文件，统计出现在这个范围的数，进入小根堆，遍历完毕后，将小根堆里的数按顺序输出出来，然后再进行下一组数的统计，下一组为-2^32 ~ (2^27 * 2) - 1

#### 解法2
准备一个大根堆，大根堆里可以存放的数据条数为2^27条，然后遍历整个10G文件，按数的大小排列，当大根堆里存满数时，下一个进来的数如果小于堆顶的数，则弹出堆顶的数，这个数进堆，如果大于堆顶的数，则跳过遍历下一个数，遍历完整个10G大文件，将堆里的数输出出来，

然后再进行遍历整个10G文件，此时只统计大于上一个堆里最大的数的数据，重复下去即可。

