### 哈希函数
简单定义：是一个输入域无限但是输出域可以有限的函数

即使出现哈希碰撞但是每个输出对应的输入个数概率均匀分布没有太大偏向

一个重要的性质：如果在input域上均匀分布，那么经过哈希并%m运算后，在0~m-1范围内输出域上同样均匀分布(离散性和均匀性)

题目case1：有40亿个无符号整数，给1G的内存，找出出现次数最多的数字

这里使用常规的哈希表存储，会出现内存溢出的问题，表里面的数字都模100，把它存在哈希表中，再遍历这100个表里面的数据，内存就不会出现溢出。

哈希表在使用的时候可以认为其增删改查的复杂度为O(1)，实际上为O(logN)
### 哈希表
经典结构：

根据key算出具体的hashcode值(h)---决定了value的存放位置

若h位置处为空，则直接将key1-value1放入

若h位置处不为空，检查是否已有key1，若已有，则更新其对应value值，否则直接按照链表格式，节点连在上一节点后面

经典应用：

场景题：如果现在有一个超级大的文件，需要统计其中重复的字符串，我们要怎么办？

目前已知的：可以供给1000台计算机，读取细节不用关心，只需要设计大概系统

思路：哈希的分流特性

具体操作：将大文件读取很多行，每一行都计算哈希值，并%1000，则这些字符串均匀分布在0-999范围内

给电脑编号0-999，对应分布在一个范围内的一些字符串用同一台电脑进行处理，达到大数据分流的效果（类似于分布式）

每台电脑只统计自己处理的重复字符串，最后将结果进行汇总即可
### 总结
大数据相关的问题，有一半都是借助于哈希来解决，因为哈希具有“相同的肯定相同，不同的均匀分布”特性

在桶不够用时可以进行扩容，代价也还可以接受，一般是O(logN)
### 布隆过滤器
（一）作用

一般用于判断某个值是否在集合中，如果在则一定返回true，但是不在也可能返回true，有失误率。即判断==某样东西一定不存在或者可能存在==。

相比于传统的List、Set、Map等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的；

判断某个元素是否存在可以使用 HashMap，时间复杂度为O(1)，但是存储容量占比高(占用内存高)，同时对于本地输入，数据在远程服务器，同时数据集大到无法一次性读进内存构建HashMap时候也存在问题。

比较针对黑名单问题和爬虫去重问题；

（二）示例

问题：判断100亿条占64字节的URL，是否为一个URL黑名单集合中元素，在则返回true，反之返回false；

解答：

方案一：使用HashSet，但是至少需要使用6400亿个字节长度（不包括指针等等占用位置），约为640G空间。

方案二：使用上述提到的哈希分流。

方案三：使用布隆过滤器，布隆过滤器是一个数组，每个元素为一个bit

实现过程：

取其中一个URL分别经过K个相互独立的哈希函数（hash1，hash2，hash3，。。。hashk），

分别得到哈希值code1，code2，code3，。。。codeK，然后对所有的哈希值%m，得到0 ~ m - 1之间的某个值，

将这个值的位置描黑（如果该位置已经描黑，则继续描黑）。将所有的URL都按照此步骤走一遍，如果某个URL对应的K个数组中位置都是描黑的，

则该URL在黑名单中，如果有一个不为黑则不在URL中。

k为哈希函数个数，m为布隆过滤器长度，n为插入的元素个数，p为误报率

如何选择适合业务的k和m值呢，公式：

m = -1 * ((n * lnp) / (ln2 ^ 2))

k = ln2 * (m / n)

p(真) = (1 - e ^ (-1 * ((n * k真) / m真))) ^ k真

### 一致性哈希
哈希可以近似的实现负载均衡，但是一旦发生设备的增删则需要将所有的数据进行迁移，可以使用一致性哈希来降低迁移代价并且实现负载均衡。

经典服务器抗压结构

比如后端共有三台存储服务器，需要将一系列键值对进行存储，首先将key经过哈希函数得到哈希值，然后将哈希值%存储器数目，这里得到 0 ~ 2 中间一个值，然后将对应的键值对存储到该存储器中即可。取值的时候同样上面步骤找到对应的存储器，然后在对应的存储器找那个查找数据。

缺点：当加机器或者减机器的时候就需要将所有存储的数据重新计算哈希值并且重新放置位置，即所有的数据都需要进行迁移。

一致性哈希

假设哈希函数的范围为：0 ~ (2 ^ 64) - 1，同样是三台存储设备，这里取三台机器的IP作为各自的识别码（只要可以唯一区别各自即可），将每台机器的IP经过哈希函数得到的哈希值对应于环上。

当放置键值对数据时候，首先将key经过哈希函数之后的哈希值（对应于环上一个位置），然后顺时针找到最近的机器，将该条记录放置到该机器上面。查找的时候同样。

结构实现

首先分别计算 m1, m2, m3 的哈希值，得到他们之间从小到大的一个数组排列，例如 [m1, m3, m2]，然后放置数据时候，将需存入的数据的 key 值经过哈希函数得到哈希值，然后将该哈希值在上面的数组排列中使用二分查找的方法得到第一个刚刚大于等于该哈希值的位置。即将记录存入该机器。

增加/删除时候的数据迁移

示例：增加机器m4，通过计算其哈希值得到其位于 m3 到 m2 之间，则只需要将 m3 到 m4 之间的数据进行数据迁移，重新计算其哈希值然后将其从 m3 迁移到 m4 即可。

问题

当机器较少的情况下，环很难得到等分，以及添加机器之后同样会发送环不等分造成无法实现负载均衡。

使用虚拟节点技术：为每个真实机器分配很多虚拟结点，然后让虚拟结点去占环上的位置；

示例：真实机器 m - 1：对应的虚拟结点 m-1-1, m-1-2……..m-1-1000;

真实机器 m - 2：对应的虚拟结点 m-2-1, m-2-2……..m-2-1000;

真实机器 m - 3：对应的虚拟结点 m-3-1, m-3-2……..m-3-1000;

真实机器和虚拟节点之间通过路由表来实现映射，实现真实机器知道自己有哪些虚拟节点，同样每个虚拟结点都可以通过路由表找到归属的物理机，通过上述范围方法得到的由虚拟节点负责的数据交给对应的物理机来处理。

