## 认识O(N * logN)的排序
#### 1.剖析递归行为和递归行为时间复杂度的估算
master公式的使用
```text
T(N) = a * T(N/b) + O(N ^ d)

T(N)为母问题的时间规模
T(N/b)为子问题的时间规模
O(N ^ d)为在一个递归过程中，除去调用递归之外，剩下的复杂度是什么
```
1. log(b,a) > d；复杂度为O(N ^ log(b,a))
2. log(b,a) = d；复杂度为O(N ^ d * logN)
3. log(b,a) < d；复杂度为O(N ^ d)

使用master公式的前提是，递归过程划分的子过程规模一致

例如：Code01_GetMax

首先母问题是N的数据规模T(N)

就getMax方法，将母问题分解为两个子问题（本来是从0 ~ N这个范围求最大值，递归将其划分为更小的数据规模：在l ~ mid和mid+1 ~ r 这两个范围求最大值；每个子问题的规模为T(N / 2)，并且发生了两次所以为 2 * T(N / 2)

除去调用子问题外，剩下的时间复杂度为O(1)

所以，该问题的Master公式可以写成：
```text
T(N) = 2 * T(N / 2) + O(1) 
```
所以 a = 2; b = 2; d = 0

所以有 log(a,b) > d

所以，这个递归求解最大值的算法的时间复杂度为：O(N ^ log(b,a)) = O(N)
#### 2. 归并排序
归并排序的时间复杂度分析：

首先归并排序可以使用master公式，因为它很显然将母问题划分成了两个等规模的子问题；除去两个子问题，归并排序还需要将help数组所有的数都刷回到原数组中，这个操作的时间复杂度很显然为O(N)

所以归并排序的master公式表示为:T(N) = 2 * T(N / 2) + O(N)

因为有：log(b,a) = d；所以复杂度为O(N ^ d * logN) = O(N * logN)