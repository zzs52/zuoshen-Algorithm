### 堆

完全二叉树：

能够保证严格地从左至右增长的树就是完全二叉树

1. 堆结构就是用数组实现的完全二叉树结构
2. 完全二叉树中如果每棵子树的最大值都在顶部就是大根堆
3. 完全二叉树中如果每棵子树的最小值都在顶部就是小根堆
4. 堆结构的heapInsert与heapify操作
5. 堆结构的增大和减少
6. 优先级队列结构，就是堆结构

使用数组作为底层数据结构，构造出一个堆结构：

如果要完成将数组作为一个底层数据结构，构造出一个假想的堆结构，我们需要知道每个子节点和其父节点的关系

1. 如果知道当前节点为arr[i],那么有左孩子节点表示为arr[2 * i + 1];右孩子节点表示为arr[2 * i + 2]
2. 如果知道当前节点为arr[i],那么其父节点可以表示为arr[(i - 1) / 2]

heapInsert和heapify这两种算法的时间复杂度不难想到为：O(logN)；因为无论是heapInsert(向上调整) 还是 heapify(向下调整) ，这两种算法最差的情况，都只是遍历了整棵树的高度，而对于完全二叉树而言，树的高度为O(logN)

### 堆排序
理解了堆结构以后，堆排序就非常容易了

堆排序的步骤

1. 遍历数组，将当前的数字heapInsert到堆中，形成大根堆
2. 交换大根堆的堆顶和堆尾的数字
3. 完成heapify操作，每次都会排好最大的数字，然后heapSize减1

堆排序的复杂度分析：

heapInsert和heapify的时间复杂度均为O(logN),这两个操作都执行了N次，所以我们可以得出堆排序的时间复杂度为O(N * logN)

并且和归并排序不同，堆排序的额外空间复杂度为O(1),迭代中只是使用了有限的几个变量，并且没有递归行为。

堆排序的优化：将heapInsert替换为heapify

heapInsert相当于从上向下构建堆，而heapify则是从下至上进行构建；因为堆是一棵完全二叉树，例如：
```text
      o
    /   \
   o     o
  / \   / \
 o   o o   o
```
heapInsert的总时间可以这样表示：
```text
O(1) + 2 * O(2) + 4 * O(3) = 17
```
heapify的总时间可以这样表示：
```text
4 * O(1) +  2 * O(2) + O(3) = 12
```
所以，heapify这种从下至上构建的方式，要更快！

上面的分析也可以通过数学归纳法求证：
```text
T(N) = N/2 * 1 + N/4 * 2 + N/8 * 3 ...
2T(N) = N + N/2 * 2 + N/4 * 3

下面的减去上面的
T(N) = N + N/2 + N/4 + N/8 ...
由此可以看出这是一个等比数列
所以它的时间复杂度可以表示为：
T(N) = aN 
所以 我们将原本的O(NlogN)的时间复杂度算法优化到了O(N)的算法！！！
```
